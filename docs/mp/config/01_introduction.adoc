
///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2020, 2022 Oracle and/or its affiliates.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= MicroProfile Config
:toc:
:toc-placement: preamble
:spec-name: MicroProfile Config
:description: {spec-name} support in Helidon MP
:keywords: helidon, mp, microprofile, config, encryption, reference
:javadoc-base-url-api: {javadoc-base-url}/io.helidon.config/io/helidon/config/
:h1Prefix: MP
:feature-name: MicroProfile Config
:common-deps-page-prefix-inc: ../../shared/dependencies/common_shared.adoc
:microprofile-bundle: true

== ToC

- Overview
- Maven
- Usage
- API
- Configuration
- Reference
- Examples
- Additional Information

== Overview

Helidon's MicroProfile Config, an implementation of Eclipse MicroProfile Config, enables you to configure your applications using MicroProfileâ€™s config configuration sources and APIs.

include::{common-deps-page-prefix-inc}[tag=maven-dependency]

[source,xml]
----
        <dependency>
            <groupId>io.helidon.microprofile.config</groupId>
            <artifactId>helidon-microprofile-config</artifactId>
        </dependency>
----

== Usage {spec-name}

Helidon MicroProfile Config is an implementation of https://github.com/eclipse/microprofile-config/[Eclipse MicroProfile Config].
You can configure your applications using MicroProfile's config configuration sources and APIs. You can also extend the
configuration using MicroProfile SPI to add custom `ConfigSource` and `Converter`.

=== {spec-name} Features

{spec-name} uses `ConfigSource` SPI to load configuration data, either from default configuration sources such
file `META-INF/microprofile-config.properties`, environment variables, and system properties; or from custom `ConfigSource`
located by Java Service Loader.

The data is then available through {spec-name} APIs to be injected into CDI Beans, or to be obtained using a `Config`
instance programmatically.

{spec-name} provides typed access to configuration values, using built-in converters, and `Converter` implementations located
by Java Service Loader.

== API

You can use MicroProfile Config API to get configuration properties by using `ConfigProvider.getConfig()`
or injecting configuration values with `@ConfigProperty`.

[source,java]
.Using ConfigProvider.getConfig()
----
org.eclipse.microprofile.config.Config config = ConfigProvider.getConfig();
config.getOptionalValue("app.greeting", String.class).orElse("Hello");
----

[source,java]
.Injecting configured properties into a constructor
----
@Inject
public GreetingProvider(@ConfigProperty(name = "app.greeting", defaultValue = "Hello") String message) {
    this.message = message
}
----

== Configuration

The example below shows how the MicroProfile configuration file `microprofile-config.properties` can be used to modify the server listen port property.

[source,properties]
----
// Application properties. This is the default greeting
app.greeting=Hello

// Microprofile server properties
server.port=8080
server.host=0.0.0.0
----

==== {spec-name} Profiles

{spec-name} supports a concept of configuration profiles. You can define a profile using the configuration property `mp.config.profile`
(when using default configuration, this can be defined as a system property, environment variable or as a property in `microprofile-config.properties`).
When a profile is defined, additional config source is loaded (`microprofile-config-profile.properties`) and properties from profile have precedence over
default properties. Profile properties can be defined using `%profile` prefix, such as `%dev.server.port`.

=== Helidon {spec-name} Features

Helidon MicroProfile Config offers the following features on top of the specification:

* *References* +
You can use `${reference}` to reference another configuration key in a key value. This
allows to configure a single key to be reused in multiple other keys.

[source,yaml]
.Example
----
uri: "http://localhost:8080"
service-1: "${uri}/service1"
service-2: "${uri}/service2"
----

* *Change support* +
Polling (or change watching) for file based config sources (not classpath based).

To enable polling for a config source created using meta configuration (see below), or using
`MpConfigSources.create(Path)`, or `YamlMpConfigSource.create(Path)`, use the following properties:

[cols="3,5"]
|===
|Property |Description

|`helidon.config.polling.enabled`   |To enable polling file for changes, uses timestamp to identify a change.

|`helidon.config.polling.duration`   |Polling period duration, defaults to 10 seconds ('PT10S`) +
See https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/Duration.html#parse(java.lang.CharSequence)

|`helidon.config.watcher.enabled`  |To enable watching file for changes using the Java `WatchService`. +
See https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/WatchService.html

|===

* *Encryption* +
You can encrypt secrets using a master password and store them in a configuration file.
The config encryption filter in MicroProfile Config is enabled by default.
For more information, see <<mp/security/03_configuration-secrets.adoc,Configuration Secrets>>.

[source,properties]
.Example of encrypted secrets
----
# Password encrypted using a master password
client_secret=${GCM=mYRkg+4Q4hua1kvpCCI2hg==}
# Password encrypted using public key (there are length limits when using RSA)
client_secret=${RSA=mYRkg+4Q4hua1kvpCCI2hg==}
# Password in clear text, can be used in development
# The system needs to be configured to accept clear text
client_secret=${CLEAR=known_password}
----

* *Meta Configuration* +
You can configure the Config using Helidon MP Config meta configuration feature. The meta-config allows configuration of config sources and other
configuration options, including addition of discovered sources and converters.

This is a Helidon specific feature available since version 2.3.0. See <<mp/config/02_MP_config_sources.adoc,Microprofile Config Sources>> for detailed information.

NOTE: For backward compatibility, we will support usage of Helidon SE meta-configuration until version 3.0.0. Using this approach causes behavior that is not compatible with {spec-name} specification.

== Reference

TODO:

== Examples

=== Default Configuration

Helidon has an internal configuration, so you are not required to provide any configuration data for your application,
though in practice you most likely would.  By default, that configuration can be overridden from three sources:
system properties, environment variables, and  the contents of `META-INF/microprofile-config.properties`.
For example, if you specify a custom server port in `META-INF/microprofile-config.properties`
then your server will listen on that port.

A main class is also required to start up the server and run the
application. By default the Quickstart sample project uses the built-in
Helidon main class. In this guide you want to use your own main class so you have
more control over the server initialization. First define your own `Main`:

[source,java]
.src/main/java/io/helidon/examples/quickstart/mp/Main.java
----
package io.helidon.examples.quickstart.mp;

import io.helidon.microprofile.server.Server;
import java.io.IOException;

public final class Main {

    private Main() { } // <1>

    public static void main(final String[] args) throws IOException {
        Server server = startServer();
        System.out.println("http://localhost:" + server.port() + "/greet");
    }

    static Server startServer() {
        return Server.create().start(); // <2>
    }

}
----
In this class, a `main` method is defined which starts the Helidon MP
server and prints out a message with the listen address.

<1> Notice that
this class has an empty no-args constructor to make sure this class
cannot be instantiated.
<2> The MicroProfile server is started with the default configuration.

Next change the project's `pom.xml` to use your main class:

[source,xml]
.pom.xml
----
    <properties>
        <mainClass>io.helidon.examples.quickstart.mp.Main</mainClass>
    </properties>
----

This property will be used to set the `Main-Class` attribute in the application jar's MANIFEST.

In your application code, Helidon uses the default configuration when you create a `Server` object without a custom `Config` object.
See the following code from the project you created.

[source,Java]
.View `Main.startServer`:
----
    static Server startServer() {
        return Server.create().start(); // <1>
    }
----
<1> There is no `Config` object being used during server creation, so the default configuration is used.

=== Source Precedence for Default Configuration

In order to properly configure your application using configuration sources, you need to understand
the precedence rules that Helidon uses to merge your configuration data.  By default,
Helidon will use the following sources in precedence order:

1. Java system properties
2. Environment variables
3. Properties specified in `META-INF/microprofile-config.properties`

Each of these sources specify configuration properties in Java Property format (key/value), like `color=red`. If any of the Helidon
required properties are not specified in one of these source, like `server.port`, then Helidon will use a default value.

NOTE: Because environment variable names are restricted to alphanumeric characters and underscores,
Helidon adds aliases to the environment configuration source, allowing entries with dotted and/or
hyphenated keys to be overriden.  For example, this mapping allows an environment variable named "APP_GREETING" to override
an entry key named "app.greeting".  In the same way, an environment variable named "APP_dash_GREETING" will map to
"app-greeting".  See <<se/config/06_advanced-configuration.adoc,Advanced Configuration>> for more information.

The following examples will demonstrate the default precedence order.

==== Default Configuration Resource

Change a configuration parameter in the default configuration resource file, `META-INF/microprofile-config.properties`.
There are no environment variable or system property overrides defined.

[source,bash]
.Change `app.greeting` in the `META-INF/microprofile-config.properties` from `Hello` to `HelloFromMPConfig`:
----
app.greeting=HelloFromMPConfig
----

[source,bash]
.Build the application, skipping unit tests, then run it:
----
mvn package -DskipTests=true
java -jar target/helidon-quickstart-mp.jar
----

[source,bash]
.Run the curl command in a new terminal window and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFromMPConfig World!" // <1>
}
----
<1> The new `app.greeting` value in `META-INF/microprofile-config.properties` is used.

===== Environment Variable Override

An environment variable has a higher precedence than the configuration properties file.

[source,bash]
.Set the environment variable and restart the application:
----
export APP_GREETING=HelloFromEnvironment
java -jar target/helidon-quickstart-mp.jar
----

[source,bash]
.Invoke the endpoint below and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFromEnvironment World!" // <1>
}
----
<1> The environment variable took precedence over the value in `META-INF/microprofile-config.properties`.

===== System Property Override

A system property has a higher precedence than environment variables.

[source,bash]
.Restart the application with a system property.  The `app.greeting` environment variable is still set:
----
java -Dapp.greeting="HelloFromSystemProperty"  -jar target/helidon-quickstart-mp.jar
----

[source,bash]
.Invoke the endpoint below and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFromSystemProperty World!" // <1>
}
----
<1> The system property took precedence over both the environment variable and `META-INF/microprofile-config.properties`.

== Accessing Config within an Application

You have used Helidon to customize configuration behavior from your code using the `Config` and
`Config.Builder` classes.  The examples in this section will demonstrate how to access that config data
at runtime.  As discussed previously, Helidon reads configuration from a config source, which uses a config parser
to translate the source into an immutable in-memory tree representing the configurationâ€™s structure and values.
Your application uses the `Config` object to access the in-memory tree, retrieving config data.

The generated project already accesses configuration data in the `GreetingProvider` class  as  follows:

[source,java]
.View the following code from `GreetingProvider.java`:
----
@ApplicationScoped // <1>
public class GreetingProvider {
    private final AtomicReference<String> message = new AtomicReference<>(); // <2>

    @Inject
    public GreetingProvider(@ConfigProperty(name = "app.greeting") String message) {   // <3>
        this.message.set(message);
    }

    String getMessage() {
        return message.get();
    }

    void setMessage(String message) {
        this.message.set(message);
    }
}
----
<1> This class is application scoped so a single instance of `GreetingProvider` will be shared across the entire application.
<2> Define a thread-safe reference that will refer to the message member variable.
<3> The value of the configuration property `app.greeting` is injected into the `GreetingProvider`.
constructor as a `String` parameter named `message`.


=== Injecting at Field Level

You can inject configuration at the field level as shown below.  Use the `volatile` keyword
since you cannot use `AtomicReference` with field level injection.

[source,yaml]
.Update the  `meta-config.yaml` with the following contents:
----
sources:
  - type: "classpath"
    properties:
      resource: "META-INF/microprofile-config.properties"  <1>
----
<1> This example only uses the default classpath source.

[source,java]
.Update the following code from `GreetingProvider.java`:
----
@ApplicationScoped
public class GreetingProvider {

    @Inject
    @ConfigProperty(name = "app.greeting") // <1>
    private volatile String message; // <2>

    String getMessage() {
        return message;
    }

    void setMessage(String message) {
        this.message = message;
    }
}
----
<1> Inject the value of `app.greeting` into the `GreetingProvider` object.
<2> Define a class member variable to hold the greeting.

[source,bash]
.Build and run the application, then invoke the endpoint and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFromMPConfig World!"
}
----

=== Injecting the Config Object

You can inject the `Config` object into the class and access it directly as shown below.

[source,java]
.Update the `GreetingProvider.java` file; 1) Add new imports and 2) Replace the `GreetingProvider` class:
----
 // <1>
import io.helidon.config.Config;
import jakarta.enterprise.context.Initialized;
import jakarta.enterprise.event.Observes;
...

@ApplicationScoped
public class GreetingProvider {
    private final AtomicReference<String> message = new AtomicReference<>();

    @Inject // <2>
    public GreetingProvider(Config config) {
        String message = config.get("app.greeting").asString().get(); // <3>
        this.message.set(message);
    }

    String getMessage() {
        return message.get();
    }

    void setMessage(String message) {
        this.message.set(message);
    }
}
----
<1> Add three new imports.
<2> Inject the `Config` object into the `GreetingProvider` object.
<3> Get the `app.greeting` value from the `Config` object and set the member variable.

[source,bash]
.Build and run the application, then invoke the endpoint and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFromMPConfig World!"
}
----


=== Navigating the Config Tree

Helidon offers a variety of methods to access in-memory configuration.  These can be categorized as _key access_ or _tree navigation_.
You have been using _key access_ for all of the examples to this point.  For example `app.greeting` is accessing
the `greeting` child node of the `app` parent node.  There are many options for access this data using navigation
methods as described in <<se/config/03_hierarchical-features.adoc,Hierarchical Configuration>> and <<se/config/06_advanced-configuration.adoc,Advanced Configuration>>.
This simple example below demonstrates how to access a child node as a detached configuration sub-tree.

[source,yaml]
.Create a file `config-file.yaml` in the `helidon-quickstart-mp` directory and add the following contents:
----
app:
  greeting:
    sender: Joe
    message: Hello-from-config-file.yaml
----

[source,yaml]
.Update the  `meta-config.yaml` with the following contents:
----
sources:
  - type: "classpath"
    properties:
      resource: "META-INF/microprofile-config.properties"
  - type: "file"
    properties:
      path: "./config-file.yaml"
----

[source,java]
.Replace `GreetingProvider` class with the following code:
----
@ApplicationScoped
public class GreetingProvider {
    private final AtomicReference<String> message = new AtomicReference<>();
    private final AtomicReference<String> sender = new AtomicReference<>();

    @Inject
    Config config;

    public void onStartUp(@Observes @Initialized(ApplicationScoped.class) Object init) {
        Config appNode = config.get("app.greeting"); // <1>
        message.set(appNode.get("message").asString().get());  // <2>
        sender.set(appNode.get("sender").asString().get());   // <3>
    }

    String getMessage() {
        return sender.get() + " says " + message.get();
    }

    void setMessage(String message) {
        this.message.set(message);
    }
}
----
<1> Get the configuration subtree where the `app.greeting` node is the root.
<2> Get the value from the `message` `Config` node.
<3> Get the value from the `sender` `Config` node.

[source,bash]
.Build and run the application, then invoke the endpoint and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "Joe says Hello-from-config-file.yaml World!"
}
----

== Integration with Kubernetes

The following example uses a Kubernetes ConfigMap to pass the configuration data to your Helidon application deployed to Kubernetes.
When the pod is created, Kubernetes will automatically create a local file within the container that has the contents of the
configuration file used for the ConfigMap.  This example will create the file at `/etc/config/config-file.properties`.

[source,java]
.Update the `Main` class and replace the `buildConfig` method:
----
  private static Config buildConfig() {
      return Config.builder()
          .sources(
              file("/etc/config/config-file.properties").optional(), // <1>
              classpath("META-INF/microprofile-config.properties")) // <2>
          .build();
  }
----
<1> The `app.greeting` value will be fetched from `/etc/config/config-file.properties` within the container.
<2> The server port is specified in `META-INF/microprofile-config.properties` within the `helidon-quickstart-mp.jar`.

[source,java]
.Update the following code from `GreetingProvider.java`:
----
@ApplicationScoped
public class GreetingProvider {

    @Inject
    @ConfigProperty(name = "app.greeting") // <1>
    private volatile String message; // <2>

    String getMessage() {
        return message;
    }

    void setMessage(String message) {
        this.message = message;
    }
}
----

[source,bash]
.Build and run the application, then invoke the endpoint and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFromConfigFile World!"
}
----

[source,bash]
.Stop the application and build the docker image:
----
docker build -t helidon-config-mp .
----

[source,bash]
.Generate a ConfigMap from `config-file.properties`:
----
kubectl create configmap helidon-configmap --from-file config-file.properties
----

[source,bash]
.View the contents of the ConfigMap:
----
kubectl get configmap helidon-configmap -o yaml
...
apiVersion: v1
data:
  config-file.properties: |   // <1>
    app.greeting=HelloFromConfigFile   // <2>
kind: ConfigMap
...
----
<1> The file `config-file.properties` will be created within the Kubernetes container.
<2> The `config-file.properties` file will have this single property defined.


[source,yaml]
.Create the Kubernetes YAML specification, named `k8s-config.yaml`, with the following contents:
----
kind: Service
apiVersion: v1
metadata:
  name: helidon-config // <1>
  labels:
    app: helidon-config
spec:
  type: NodePort
  selector:
    app: helidon-config
  ports:
    - port: 8080
      targetPort: 8080
      name: http
---
kind: Deployment
apiVersion: extensions/v1beta1
metadata:
  name: helidon-config
spec:
  replicas: 1 // <2>
  template:
    metadata:
      labels:
        app: helidon-config
        version: v1
    spec:
      containers:
        - name: helidon-config
          image: helidon-config-mp
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
          volumeMounts:
            - name: config-volume
              mountPath: /etc/config // <3>
      volumes:
        - name: config-volume
          configMap:
            # Provide the name of the ConfigMap containing the files you want
            # to add to the container
            name:  helidon-configmap // <4>
----
<1> A service of type `NodePort` that serves the default routes on port `8080`.
<2> A deployment with one replica of a pod.
<3> Mount the ConfigMap as a volume at `/etc/config`.  This is where Kubernetes will create `config-file.properties`.
<4> Specify the ConfigMap which contains the configuration data.


[source,bash]
.Create and deploy the application into Kubernetes:
----
kubectl apply -f ./k8s-config.yaml
----

[source,bash]
.Get the service information:
----
kubectl get service/helidon-config
----

[source,bash]
----
NAME             TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
helidon-config   NodePort   10.99.159.2   <none>        8080:31143/TCP   8s // <1>
----
<1> A service of type `NodePort` that serves the default routes on port `31143`.

[source,bash]
.Verify the configuration endpoint using port `31143`, your port will likely be different:
----
curl http://localhost:31143/greet
...
{
  "message": "HelloFromConfigFile World!" // <1>
}
----
<1> The greeting value from `/etc/config/config-file.properties` within the container was used.


You can now delete the Kubernetes resources that were just created during this example.

[source,bash]
.Delete the Kubernetes resources:
----
kubectl delete -f ./k8s-config.yaml
kubectl delete configmap  helidon-configmap
----


== Additional Information

- link:{javadoc-base-url-api}spi/package-summary.html[Helidon Config SPI]
- link:{javadoc-base-url-api}package-summary.html[Helidon Config API]
- link:https://download.eclipse.org/microprofile/microprofile-config-1.3/apidocs/[Eclispe MicroProfile API]

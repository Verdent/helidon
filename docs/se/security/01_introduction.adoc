///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2018, 2022 Oracle and/or its affiliates.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= Security Introduction
:h1Prefix: SE
:description: Helidon Security introduction
:keywords: helidon, security
:feature-name: Security
:common-deps-page-prefix-inc: ../../shared/dependencies/common_shared.adoc


== ToC

- Overview
- Maven Coordinates
- Usage
- API
- Configuration
- Reference
- Examples
- Additional Information

== Overview

Helidon Security provides authentication, authorization and auditing for your Helidon application.

include::{common-deps-page-prefix-inc}[tag=maven-dependency]

[source,xml]
----
<dependency>
    <groupId>io.helidon.security</groupId>
    <artifactId>helidon-security</artifactId>
</dependency>
----

== Usage

Helidon Security provides the following features

. Authentication - support for authenticating incoming requests, creating a
 security Subject with Principal and Grants. Principal represents current user/service.
 Grant may represent a Role, Scope etc.
 Responsibility to create Principals and Grants lies with with AuthenticationProvider
 SPI. The following Principals are expected and supported out of the box:
.. UserPrincipal - the party is an end-user (e.g. a person) - there can be zero to
 one user principals in a subject
.. ServicePrincipal - the party is a service (e.g. a computer program) - there can
 be zero to one service principals in a subject
. Authorization - support for authorizing incoming requests. Out-of-the-box the
 security module supports ABAC and RBAC (Attribute based access control and Role based
 access control). RBAC is handled through RolesAllowed annotation (for integrations that
 support injection).
. Outbound security - support for propagating identity or (in general) securing
 outbound requests. Modification of a request to include outbound security is
 responsibility of OutboundSecurityProvider SPI
. Audit - security module audits most important events through its own API
 (e.g. Authentication events, Authorization events, outbound security events).
 A default AuditProvider is provided as well, logging to Java util logging (JUL)
 logger called "AUDIT" (may be overridden through configuration). AuditProvider
 SPI may be implemented to support other auditing options.

Security module is quite HTTP centric (as most common use cases are related to
 HTTP REST), though it is not HTTP specific (the security module may be used to
 secure even other transports, such as JMS, Kafka messages etc. if an appropriate
 integration module is developed, as all APIs can be mapped to a non-HTTP
 protocol). Nevertheless there may be security providers that only make sense with
 HTTP (such as HTTP digest authentication).

== API

To integrate with a container, or to use Security standalone, we must
 create an instance of security.
In general, Security supports three approaches

- a fluent-API builder pattern - you configure everything "by hand"
- a configuration based pattern - you configure everything in a configuration file
- hybrid - you load a builder from configuration and update it in a program

Once a security instance is built, it can be used to initialize an
 <<_cloud_security_container_integrations,integration with a container>>, or to
 use security from a program directly:

[source,java]
.Security direct usage
----
// create a security context
SecurityContext context = security.contextBuilder(UUID.randomUUID().toString())
                .env(SecurityEnvironment.builder()
                             .method("get")
                             .path("/test")
                             .transport("http")
                             .header("Authorization", "Bearer abcdefgh")
                             .build())
                .build();

// use the context to authenticate a request
context.atnClientBuilder()
                .submit()
                .whenComplete((response, exception) -> {
                    // this is to show the features, not a real-world production code...
                    if (null == exception) {
                        if (response.getStatus().isSuccess()) {
                            System.out.println(response.getUser());
                            System.out.println(response.getService());
                        } else {
                            System.out.println("Authentication failed: " + response.getDescription());
                        }
                    } else {
                        exception.printStackTrace();
                    }
                });
----

=== Builder pattern

[source,java]
.Security through a builder
----
Security security = Security.builder()
        // create a provider instance based on the provider documentation
        .addProvider(...)
        .build();
----

== Configuration

See <<_tools,Secure config>> for details about encrypting passwords in
 configuration files.

[source,java]
.Security from configuration
----
// uses io.helidon.Config
Security security = Security.create(config);
----

[source,yaml]
.Security from configuration - application.yaml
----
# Uses config encryption filter to encrypt passwords
security:
  providers:
  - abac:
  - http-basic-auth:
      realm: "helidon"
      users:
      - login: "jack"
        password: "${CLEAR=password}"
        roles: ["user", "admin"]
      - login: "jill"
        password: "${CLEAR=password}"
        roles: ["user"]
----

==== Overriding configuration
When a configuration needs to be overridden, we may have problems with the list
type of the `providers` configuration. To simplify overrides using properties,
you can explicitly setup a type of provider using a `type` key.

Example:
[source,properties]
----
security.providers.1.type=header-atn
security.providers.1.header-atn.authenticate=false
----

Would explicitly override the second provider (`http-basic-auth` in example above) with
`header-atn` provider. Note that the `type` and the key of the provider must match.

=== Hybrid pattern (Builder & Configuration)

[source,java]
.Security from configuration and builder
----
// uses io.helidon.Config
Security security = Security.builder(config)
                .addProvider(...)
                .build();

// or reverse order:
Security security = Security.builder()
                .addProvider()
                .config(config)
                .build();
----

== Reference

TODO:

== Examples

TODO:

== Additional Information


== Containers Integration

=== Cloud Security Container Integrations

The following containers are integrated with Helidon Security:

==== Web server

Integration of <<webserver/01_introduction.adoc,reactive web server>>

[source,xml]
.Maven Dependency
----
<dependency>
    <groupId>io.helidon.security.integration</groupId>
    <artifactId>helidon-security-integration-webserver</artifactId>
</dependency>
----

==== Bootstrapping

There are two steps to configure security with web server:

1. Create security instance and register it with server
2. Protect routes of web server with various security features

[source,java]
.Example using builders
----
// web server's Routing
Routing.builder()
    // This is step 1 - register security instance with web server processing
    // security - instance of security either from config or from a builder
    // securityDefaults - default enforcement for each route that has a security definition
    .register(WebSecurity.create(security).securityDefaults(WebSecurity.authenticate()))
    // this is step 2 - protect a route
    // protect this route with authentication (from defaults) and role "user"
    .get("/service1", WebSecurity.rolesAllowed("user"), (req, res) -> {
        processService1Request(req, res);
    })
    .build();
----

[source,java]
.Example using configuration
----
Routing.builder()
    // helper method to load both security and web server security from configuration
    .register(WebSecurity.create(config))
    // continue with web server route configuration
    .build();
----

[source,yaml]
.Example using configuration (YAML)
----
# This may change in the future - to align with web server configuration, once it is supported
security.web-server:
  # Configuration of integration with web server
  defaults:
    authenticate: true
  paths:
    - path: "/service1/[/{*}]"
      methods: ["get"]
      roles-allowed: ["user"]
----

include::../../shared/security/helidon-endpoints.adoc[]

==== Jersey

Integration of Jersey (JAX-RS implementation) both for inbound and outbound security.

[source,xml]
.Maven Dependency
----
<dependency>
    <groupId>io.helidon.security.integration</groupId>
    <artifactId>helidon-security-integration-jersey</artifactId>
</dependency>
----

===== Inbound security

[source,java]
.Integrate with Jersey
----
ResourceConfig resourceConfig = new ResourceConfig()
    // register JAX-RS resource
    .register(JaxRsResource.class)
    // integrate security
    .register(new io.helidon.security.jersey.SecurityFeature(security));
----

==== Protecting a resource

The current approach does not have a configuration option. The security must be
configured through annotations.
Security currently supports @Authenticated and @Authorized. When a resource is annotated with one of these
annotations (application class, resource class, or resource method), security will
be triggered.

[source,java]
.Securing a resource method
----
// this is sufficient for security to be triggered, see javadoc for further details
@Authenticated
@Path("/{name}")
@GET
@Produces(MediaType.TEXT_PLAIN)
// due to Jersey approach to path matching, we need two methods to match both the "root" and "root" + subpaths
public String getHelloName(@PathParam("name") String name) {
    return "Hello " + name + ", your current subject: " + securityContext.getSubject();
}
----

==== Access context

[source,java]
.Support in a JAX-RS resource
----
// inject io.helidon.security.SecurityContext
@Context
private SecurityContext securityContext;

----


==== Outbound security
Outbound security is automatically registered with Jersey client.
The provider must have outbound security configured for identity to be propagated.

[source,xml]
.Maven Dependency
----
<dependency>
    <groupId>io.helidon.security.integration</groupId>
    <artifactId>helidon-security-integration-jersey-client</artifactId>
</dependency>
----

[source,java]
.Call remote target with outbound security
----
Client client = ClientBuilder.newClient();

try {
    // call the resource, will propagate identity as configured in Security
    String response = client.target("http://www.google.com")
        .request()
        // configure the security context for this request (as client and targets may be re-used)
        .property(ClientSecurity.PROPERTY_CONTEXT, securityContext)
        .get(String.class);
} finally {
    client.close();
}
----


== Security Tools

=== Tools

==== Secure configuration

Support for encrypting secrets in configuration files.
[source,xml]
.Maven Dependency
----
<dependency>
    <groupId>io.helidon.config</groupId>
    <artifactId>helidon-config-encryption</artifactId>
</dependency>
----

==== Key and certificate configuration

Configuration support for accessing private keys, public keys, certificates and
certificate chains including runtime access to instance of such.

[source,xml]
.Maven Dependency
----
<dependency>
    <groupId>io.helidon.common</groupId>
    <artifactId>helidon-common-key-util</artifactId>
</dependency>
----


== Extending Security

This guide describes how you can extend the Security component.

The component has the following extension points:

* Security providers
* Provider selection policy
* Integration with a framework

=== Security providers
You can build a custom provider for each type of security concept supported.
By default, each provider is asynchronous. For simple cases, a class
exists in "spi" package to help implement a synchronous approach:
`SynchronousProvider`.

You have two options:

1. Implement a provider interface and reference it in configuration (or from
builder) by class
2. Implement a provider interface and provide a Java `ServiceLoader` service implementing
`io.helidon.security.spi.SecurityProviderService`

The second option allows for easier configuration, as the configuration key can be
used without a class definition and creates a default name of a provider.

==== Authentication provider
To create a custom authentication provider, create a class that implements
`io.helidon.security.spi.AuthenticationProvider`.
Implementation is responsible for taking a request and asserting a subject
based on that request.
In case the protocol is multi-request (e.g. challenge for basic authentication),
you have the possibility to return specific headers and a response code. The
default semantics of these is HTTP, though providers may exist that are not
HTTP specific.

==== Authorization provider
To create a custom authorization provider, create a class that implements
`io.helidon.security.spi.AuthorizationProvider`.
Implementation is responsible for taking a request and checking whether the
request can continue processing (e.g. if the current user and/or service subject
has a right to execute it).

If authentication is configured, the Security component guarantees it resolved
before authorization.

==== Outbound security provider
To create a custom outbound security provider, create a class that implements
`io.helidon.security.spi.OutboundSecurityProvider`.
Implementation can update outgoing message headers to handle
security for an outgoing request (e.g. identity propagation, mapping etc.).

==== Audit provider
To create a custom audit provider, create a class that implements
`io.helidon.security.spi.AuditProvider`.
Security component feeds each audit provider all messages from all components
that invoke audit method on "Security" class, including internal audit events
pre-configured in the component itself (e.g. authentication, authorization
events).

Implementation may do whatever desired with these messages, e.g.:

* filter them
* log them
* store them to a database
* forward them to an audit component
* discard them

=== Provider selection policy
Each request is processed by a single authentication and/or authorization
provider. The selection policy provides the security component information about
which provider to use. Out of the box, there are three policies:

1. "First" policy - first configured provider (or explicitly defined default
provider) is used by default, if a named provider is requested, it would be used
2. "Composite" policy - this policy allows for a sequence of providers to be
executed (e.g. one request may have more than one provider) - used for example to
resolve service and user authentication
3. "Class" policy - this allows usage of a custom policy defined by fully
qualified class name

To create a custom provider selection policy, create a class that implements
"io.helidon.security.spi.ProviderSelectionPolicy".

=== Framework integration
The Security component supports integration with Helidon WebServer (`helidon-security-integration-webserver`)
and with Jersey (`helidon-security-integration-jersey`).

Existing integrations (WebServer and Jersey) use Helidon Security APIs that are available to integrate any
framework/application (for example we could integrate security with messaging, such as JMS).

To create a new integration, an instance of `Security` class is needed, as it handles
all configured providers. Usually a single `Security` instance is used for an application.

`Security` is then used to create an instance of `SecurityContext`, which is used
for interaction with a single user. A single `SecurityContext` is created for each HTTP
request in Jersey and WebServer integration.

`SecurityContext` is used to invoke authentication, authorization, and outbound security requests.

Helidon Security also defines a set of annotations:

* `@Authenticated` - access to resources must follow authentication rules defined by the annotation
* `@Authorized` - access to resources must follow authorization rules defined by the annotation
* `@Audited` - to configure auditing

If the protected resources (in Helidon MP, these are JAX-RS resource classes and methods) can
be annotated, the integration component must use these annotations when deciding how to secure
the endpoint. For example, the Jersey integration checks whether the @Authenticated annotation exists. If it does, then
the integration component attempts to authenticate the request.

Because other components of Helidon Security (such as ABAC validators) query the request for annotations,
the integration component should also collect all annotations from the resource and correctly configure
them when creating the security request.

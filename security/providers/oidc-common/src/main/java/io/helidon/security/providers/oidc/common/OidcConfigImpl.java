/*
 * Copyright (c) 2018, 2022 Oracle and/or its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.helidon.security.providers.oidc.common;

import java.net.URI;
import java.time.Duration;
import java.util.Collections;
import java.util.logging.Logger;

import javax.json.Json;
import javax.json.JsonReaderFactory;
import javax.ws.rs.client.Client;
import javax.ws.rs.client.WebTarget;

import io.helidon.common.configurable.Resource;
import io.helidon.common.http.FormParams;
import io.helidon.security.SecurityException;
import io.helidon.security.jwt.jwk.JwkKeys;
import io.helidon.security.util.TokenHandler;
import io.helidon.webclient.WebClient;
import io.helidon.webclient.WebClientRequestBuilder;
import io.helidon.webserver.cors.CrossOriginConfig;

/**
 * Configuration of OIDC usable from all resources that utilize OIDC specification, such as security provider, web server
 * extension and IDCS connectivity.
 * <p>
 * Some of the configuration options below use "resource" type. The following configuration
 * can be used for a resource (example for oidc-metadata key):
 * {@code
 * oidc-metadata-path: "path/on/filesystem"
 * oidc-metadata-resource-path: "class-path/resource"
 * oidc-metadata-url: "URI on the net"
 * oidc-metadata-content-plain: "Value of the resource in plain text"
 * oidc-metadata-content: "Value in base64 encoded bytes"
 * }
 * <p>
 * Configuration options required (under security.providers[].${name}):
 * <table class="config">
 * <caption>Mandatory configuration parameters</caption>
 * <tr>
 *     <th>key</th>
 *     <th>description</th>
 * </tr>
 * <tr>
 *     <td>client-id</td>
 *     <td>Client ID as generated by OIDC server</td>
 * </tr>
 * <tr>
 *     <td>client-secret</td>
 *     <td>Client secret as generated by OIDC server</td>
 * </tr>
 * <tr>
 *     <td>identity-uri</td>
 *     <td>URI of the identity server, base used to retrieve OIDC metadata</td>
 * </tr>
 * <tr>
 *     <td>frontend-uri</td>
 *     <td>Fully URI of the frontend for redirects back from OIDC server (e.g. http://myserver/myApp)</td>
 * </tr>
 * </table>
 *
 * <table class="config">
 * <caption>Optional configuration parameters</caption>
 * <tr>
 *     <th>key</th>
 *     <th>default value</th>
 *     <th>description</th>
 * </tr>
 * <tr>
 *     <td>proxy-protocol</td>
 *     <td>http</td>
 *     <td>Proxy protocol to use when proxy is used.</td>
 * </tr>
 * <tr>
 *     <td>proxy-host</td>
 *     <td>null</td>
 *     <td>Proxy host to use. When defined, triggers usage of proxy for HTTP requests.</td>
 * </tr>
 * <tr>
 *     <td>proxy-port</td>
 *     <td>80</td>
 *     <td>Port of the proxy server to use</td>
 * </tr>
 * <tr>
 *     <td>redirect-uri</td>
 *     <td>/oidc/redirect</td>
 *     <td>URI to register web server component on, used by the OIDC server to
 *          redirect authorization requests to after a user logs in or approves scopes. Note that usually the redirect URI
 *          configured here must be the same one as configured on OIDC server.</td>
 * </tr>
 * <tr>
 *     <td>scope-audience</td>
 *     <td>empty string</td>
 *     <td>Audience of the scope required by this application. This is prefixed to
 *          the scope name when requesting scopes from the identity server.</td>
 * </tr>
 * <tr>
 *     <td>cookie-use</td>
 *     <td>true</td>
 *     <td>Whether to use cookie to store JWT. If used, redirects happen only in case the user
 *              is not authenticated or has insufficient scopes</td>
 * </tr>
 * <tr>
 *     <td>cookie-name</td>
 *     <td>JSESSIONID</td>
 *     <td>Name of the cookie</td>
 * </tr>
 * <tr>
 *     <td>cookie-domain</td>
 *     <td>null</td>
 *     <td>Domain the cookie is valid for. Not used by default</td>
 * </tr>
 * <tr>
 *     <td>cookie-path</td>
 *     <td>/</td>
 *     <td>Path the cookie is valid for.</td>
 * </tr>
 * <tr>
 *     <td>cookie-max-age-seconds</td>
 *     <td>null</td>
 *     <td>When using cookie, used to set MaxAge attribute of the cookie, defining
 *              how long the cookie is valid.</td>
 * </tr>
 * <tr>
 *     <td>cookie-http-only</td>
 *     <td>true</td>
 *     <td>When using cookie, if set to true, the HttpOnly attribute will be configured.</td>
 * </tr>
 * <tr>
 *     <td>cookie-secure</td>
 *     <td>false</td>
 *     <td>When using cookie, if set to true, the Secure attribute will be configured.</td>
 * </tr>
 * <tr>
 *     <td>cookie-same-site</td>
 *     <td>Lax</td>
 *     <td>When using cookie, used to set the SameSite cookie value. Can be "Strict" or "Lax".
 *     Setting this to "Strict" will result in infinite redirects when calling OIDC on a different host.
 *     </td>
 * </tr>
 * <tr>
 *     <td>query-param-use</td>
 *     <td>false</td>
 *     <td>Whether to expect JWT in a query parameter</td>
 * </tr>
 * <tr>
 *     <td>query-param-name</td>
 *     <td>accessToken</td>
 *     <td>Name of a query parameter that contains the JWT token when parameter is used.</td>
 * </tr>
 * <tr>
 *     <td>header-use</td>
 *     <td>false</td>
 *     <td>Whether to expect JWT in a header field.</td>
 * </tr>
 * <tr>
 *     <td>header-token</td>
 *     <td>"Authorization" header with prefix "bearer "</td>
 *     <td>A {@link TokenHandler} configuration to process header containing a JWT</td>
 * </tr>
 * <tr>
 *     <td>oidc-metadata-well-known</td>
 *     <td>true</td>
 *     <td>If set to true, metadata will be loaded from default (well known)
 *          location, unless it is explicitly defined using oidc-metadata-resource. If set to false, it would not be loaded even
 *          if oidc-metadata-resource is not defined. In such a case all URIs must be explicitly
 *          defined (e.g. token-endpoint-uri).</td>
 * </tr>
 * <tr>
 *     <td>oidc-metadata.resource</td>
 *     <td>identity-uri/.well-known/openid-configuration</td>
 *     <td>Resource configuration for OIDC Metadata containing endpoints to various identity services, as well as information
 *     about the identity server. See {@link Resource#create(io.helidon.config.Config)}</td>
 * </tr>
 * <tr>
 *     <td>token-endpoint-uri</td>
 *     <td>token_endpoint in OIDC metadata, or identity-url/oauth2/v1/token if not available</td>
 *     <td>URI of a token endpoint used to obtain a JWT based on the authentication code.</td>
 * </tr>
 * <tr>
 *     <td>authorization-endpoint-uri</td>
 *     <td>"authorization_endpoint" in OIDC metadata, or identity-uri/oauth2/v1/authorize if not available</td>
 *     <td>URI of an authorization endpoint used to redirect users to for logging-in.</td>
 * </tr>
 * <tr>
 *     <td>validate-with-jwk</td>
 *     <td>true</td>
 *     <td>When true  - validate against jwk defined by "sign-jwk", when false
 *          validate JWT through OIDC Server endpoint "validation-endpoint-uri"</td>
 * </tr>
 * <tr>
 *     <td>sign-jwk.resource</td>
 *     <td>"jwks-uri" in OIDC metadata, or identity-uri/admin/v1/SigningCert/jwk if not available, only needed
 *              when jwt validation is done by us</td>
 *     <td>A resource pointing to JWK with public keys of signing certificates used to validate JWT.
 *     See {@link Resource#create(io.helidon.config.Config)}</td>
 * </tr>
 * <tr>
 *     <td>introspect-endpoint-uri</td>
 *     <td>"introspection_endpoint" in OIDC metadata, or identity-uri/oauth2/v1/introspect</td>
 *     <td>When validate-with-jwk is set to "false", this is the endpoint used</td>
 * </tr>
 * <tr>
 *     <td>base-scopes</td>
 *     <td>{@value OidcConfig.Builder#DEFAULT_BASE_SCOPES}</td>
 *     <td>Configure scopes to be requested by default. If the scope has a qualifier, it must be included here</td>
 * </tr>
 * <tr>
 *     <td>redirect</td>
 *     <td>true</td>
 *     <td>Whether to redirect to identity server when authentication failed.</td>
 * </tr>
 * <tr>
 *     <td>realm</td>
 *     <td>helidon</td>
 *     <td>Realm returned in HTTP response if redirect is not enabled or possible.</td>
 * </tr>
 * <tr>
 *     <td>redirect-attempt-param</td>
 *     <td>{@value OidcConfig.Builder#DEFAULT_ATTEMPT_PARAM}</td>
 *     <td>Query parameter holding the number of times we redirected to an identity server. Customizable to prevent
 *     conflicts with application parameters</td>
 * </tr>
 * <tr>
 *     <td>max-redirects</td>
 *     <td>{@value OidcConfig.Builder#DEFAULT_MAX_REDIRECTS}</td>
 *     <td>Maximal number of times we can redirect to an identity server. When the number is reached, no further redirects
 *     happen and the request finishes with an error (status {@code 401})</td>
 * </tr>
 * <tr>
 *     <td>server-type</td>
 *     <td>&nbsp;</td>
 *     <td>Type of identity server. Currently supported is {@code idcs} or not configured (for default).</td>
 * </tr>
 * <tr>
 *     <td>{@code client-timeout-millis}</td>
 *     <td>30 seconds</td>
 *     <td>Timeout on HTTP client calls</td>
 * </tr>
 * <tr>
 *     <td>{@code cookie-encryption-enabled}</td>
 *     <td>Depends on other configuration</td>
 *     <td>Whether cookies should be encrypted. Will be enabled if logout is enabled.</td>
 * </tr>
 * <tr>
 *     <td>{@code cookie-encryption-password}</td>
 *     <td>Generated for this service (as a file)</td>
 *     <td>Encryption password to be used for symmetric cipher. Must be the same for all services that are intended
 *     to share a cookie as a form of authentication</td>
 * </tr>
 * <tr>
 *     <td>{@code cookie-encryption-name}</td>
 *     <td>&nbsp;</td>
 *     <td>Name of encryption configuration in {@link io.helidon.security.Security}. If used, security must be registered
 *     in curent context or in global context (this is done automatically in Helidon MP).</td>
 * </tr>
 * <tr>
 *     <td>{@code logout-endpoint-uri}</td>
 *     <td>From well known metadata endpoint</td>
 *     <td>Endpoint to redirect user to log out from OIDC server.</td>
 * </tr>
 * <tr>
 *     <td>{@code post-logout-uri}</td>
 *     <td>&nbsp;</td>
 *     <td>Required if logout is enabled. Endpoint the OIDC server redirects back to after logging user out.</td>
 * </tr>
 * <tr>
 *     <td>{@code logout-enabled}</td>
 *     <td>{@code false}</td>
 *     <td>Whether logout support should be enabled. Requires encryption of cookies (and cookies must be used).</td>
 * </tr>
 * <tr>
 *     <td>{@code cors}</td>
 *     <td>&nbsp;</td>
 *     <td>Cross-origin resource sharing settings. See {@link io.helidon.webserver.cors.CrossOriginConfig}.</td>
 * </tr>
 * <tr>
 *     <td>{@code force-https-redirects}</td>
 *     <td>&nbsp;</td>
 *     <td>Force https for redirects to identity provider.
 *     This is helpful if you have a frontend SSL or cloud load balancer in front and Helidon is serving plain http.</td>
 * </tr>
 * </table>
 */
final class OidcConfigImpl implements OidcConfig {

    private static final Logger LOGGER = Logger.getLogger(OidcConfigImpl.class.getName());

    private final String redirectUri;
    private final String logoutUri;
    private final boolean logoutEnabled;
    private final boolean useCookie;
    private final boolean useParam;
    private final String paramName;
    private final URI identityUri;
    private final WebTarget tokenEndpoint;
    private final URI tokenEndpointUri;
    private final String scopeAudience;
    private final String frontendUri;
    private final boolean useHeader;
    private final TokenHandler headerHandler;
    private final String authorizationEndpointUri;
    private final String clientId;
    private final JwkKeys signJwk;
    private final String baseScopes;
    private final boolean validateJwtWithJwk;
    private final WebTarget introspectEndpoint;
    private final String issuer;
    private final String audience;
    private final Client appClient;
    private final Client generalClient;
    private final boolean redirect;
    private final String realm;
    private final String redirectAttemptParam;
    private final int maxRedirects;
    private final ClientAuthentication tokenEndpointAuthentication;
    private final String clientSecret;
    private final WebClient webClient;
    private final WebClient appWebClient;
    private final URI introspectUri;
    private final Duration clientTimeout;
    private final OidcCookieHandler tokenCookieHandler;
    private final OidcCookieHandler idTokenCookieHandler;
    private final URI postLogoutUri;
    private final URI logoutEndpointUri;
    private final CrossOriginConfig crossOriginConfig;
    private final boolean forceHttpsRedirects;
    private final Duration tokenRefreshSkew;

    OidcConfigImpl(Builder builder) {
        this.clientId = builder.clientId;
        this.useCookie = builder.useCookie;
        this.useParam = builder.useParam;
        this.paramName = builder.paramName;
        this.frontendUri = builder.frontendUri;
        this.redirectUri = builder.redirectUri;
        this.logoutUri = builder.logoutUri;
        this.logoutEnabled = builder.logoutEnabled;
        this.postLogoutUri = builder.postLogoutUri;
        this.useHeader = builder.useHeader;
        this.headerHandler = builder.headerHandler;
        this.authorizationEndpointUri = builder.authorizationEndpointUri.toString();
        this.logoutEndpointUri = builder.logoutEndpointUri;
        this.baseScopes = builder.baseScopes;
        this.validateJwtWithJwk = builder.validateJwtWithJwk;
        this.issuer = builder.issuer;
        this.audience = builder.audience;
        this.identityUri = builder.identityUri;
        this.redirect = builder.redirect;
        this.realm = builder.realm;
        this.redirectAttemptParam = builder.redirectAttemptParam;
        this.maxRedirects = builder.maxRedirects;
        this.appClient = builder.appClient;
        this.appWebClient = builder.appWebClient;
        this.webClient = builder.webClient;
        this.tokenEndpoint = builder.tokenEndpoint;
        this.tokenEndpointUri = builder.tokenEndpointUri;
        this.generalClient = builder.generalClient;
        this.tokenEndpointAuthentication = builder.tokenEndpointAuthentication;
        this.clientTimeout = builder.clientTimeout;
        this.forceHttpsRedirects = builder.forceHttpsRedirects;

        if (tokenEndpointAuthentication == ClientAuthentication.CLIENT_SECRET_POST) {
            // we should only store this if required
            this.clientSecret = builder.clientSecret;
        } else {
            this.clientSecret = null;
        }

        if (builder.signJwk == null) {
            this.signJwk = JwkKeys.builder().build();
        } else {
            this.signJwk = builder.signJwk;
        }

        if (validateJwtWithJwk) {
            this.introspectEndpoint = null;
            this.introspectUri = null;
        } else {
            this.introspectUri = builder.introspectUri;
            this.introspectEndpoint = appClient.target(builder.introspectUri);
        }

        this.tokenCookieHandler = builder.tokenCookieBuilder.build();
        if (logoutEnabled) {
            builder.idTokenCookieBuilder.encryptionEnabled(true);
        }
        this.idTokenCookieHandler = builder.idTokenCookieBuilder.build();

        if ((builder.scopeAudience == null) || builder.scopeAudience.trim().isEmpty()) {
            this.scopeAudience = "";
        } else {
            String tmp = builder.scopeAudience.trim();
            if (tmp.endsWith("/")) {
                this.scopeAudience = tmp;
            } else {
                this.scopeAudience = tmp + "/";
            }
        }
        this.crossOriginConfig = builder.crossOriginConfig;
        this.tokenRefreshSkew = builder.tokenRefreshSkew;

        LOGGER.finest(() -> "OIDC Scope audience: " + scopeAudience);
        LOGGER.finest(() -> "Redirect URI with host: " + frontendUri + redirectUri);
    }

    /**
     * JWK used for signature validation.
     *
     * @return set of keys used use to verify tokens
     * @see Builder#signJwk(JwkKeys)
     */
    @Override
    public JwkKeys signJwk() {
        return signJwk;
    }

    /**
     * Redirection URI.
     *
     * @return uri the OIDC server redirects back to
     * @see Builder#redirectUri(String)
     */
    @Override
    public String redirectUri() {
        return redirectUri;
    }

    /**
     * Whether to force https when redirecting to identity provider.
     *
     * @return {@code true} to force use of https
     */
    @Override
    public boolean forceHttpsRedirects() {
        return forceHttpsRedirects;
    }

    /**
     * Whether logout is enabled.
     *
     * @return {@code true} if logout is enabled
     */
    @Override
    public boolean logoutEnabled() {
        return logoutEnabled;
    }

    /**
     * Logout URI.
     *
     * @return uri that processes logout in Helidon and redirects to OIDC server logout
     * @see Builder#logoutUri(String)
     */
    @Override
    public String logoutUri() {
        return logoutUri;
    }

    /**
     * Post logout redirect URI.
     *
     * @return uri that OIDC server redirects to once logout is finished
     * @see Builder#postLogoutUri(java.net.URI)
     */
    @Override
    public URI postLogoutUri() {
        return postLogoutUri;
    }

    /**
     * Token endpoint of the OIDC server.
     *
     * @return target the endpoint is on
     * @see Builder#tokenEndpointUri(URI)
     * @deprecated Please use {@link #appWebClient()} and {@link #tokenEndpointUri()} instead; result of moving to
     *      reactive webclient from JAX-RS client
     */
    @Override
    public WebTarget tokenEndpoint() {
        return tokenEndpoint;
    }

    /**
     * Token endpoint URI.
     *
     * @return endpoint URI
     * @see Builder#tokenEndpointUri(java.net.URI)
     */
    @Override
    public URI tokenEndpointUri() {
        return tokenEndpointUri;
    }

    /**
     * Whether to use query parameter to get the information from request.
     *
     * @return if query parameter should be used
     * @see Builder#useParam(Boolean)
     */
    @Override
    public boolean useParam() {
        return useParam;
    }

    /**
     * Query parameter name.
     *
     * @return name of the query parameter to use
     * @see Builder#paramName(String)
     */
    @Override
    public String paramName() {
        return paramName;
    }

    /**
     * Whether to use cooke to get the information from request.
     *
     * @return if cookie should be used
     * @see Builder#useCookie(Boolean)
     */
    @Override
    public boolean useCookie() {
        return useCookie;
    }

    /**
     * Cookie name.
     *
     * @return name of the cookie to use
     * @see Builder#cookieName(String)
     * @deprecated use {@link #tokenCookieHandler()} instead
     */
    @Override
    public String cookieName() {
        return tokenCookieHandler.cookieName();
    }

    /**
     * Additional options of the cookie to use.
     *
     * @return cookie options to use in cookie string
     * @see Builder#cookieHttpOnly(Boolean)
     * @see Builder#cookieDomain(String)
     * @deprecated please use {@link #tokenCookieHandler()} instead
     */
    @Override
    public String cookieOptions() {
        return tokenCookieHandler.createCookieOptions();
    }

    /**
     * Cookie handler to create cookies or unset cookies for token.
     *
     * @return a new cookie handler
     */
    @Override
    public OidcCookieHandler tokenCookieHandler() {
        return tokenCookieHandler;
    }

    /**
     * Cookie handler to create cookies or unset cookies for id token.
     *
     * @return a new cookie handler
     */
    @Override
    public OidcCookieHandler idTokenCookieHandler() {
        return idTokenCookieHandler;
    }

    /**
     * Whether to use HTTP header to get the information from request.
     *
     * @return if header should be used
     * @see Builder#useHeader(Boolean)
     */
    @Override
    public boolean useHeader() {
        return useHeader;
    }

    /**
     * {@link TokenHandler} to extract header information from request.
     *
     * @return handler to extract header
     * @see Builder#headerTokenHandler(TokenHandler)
     */
    @Override
    public TokenHandler headerHandler() {
        return headerHandler;
    }

    /**
     * Prefix of a cookie header formed by name and "=".
     *
     * @return prefix of cookie value
     * @see Builder#cookieName(String)
     * @deprecated use {@link io.helidon.security.providers.oidc.common.OidcCookieHandler} instead, this method
     *      will no longer be avilable
     */
    @Override
    public String cookieValuePrefix() {
        return tokenCookieHandler.cookieValuePrefix();
    }

    /**
     * Audience URI of custom scopes.
     *
     * @return scope audience
     * @see Builder#scopeAudience(String)
     */
    @Override
    public String scopeAudience() {
        return scopeAudience;
    }

    /**
     * Authorization endpoint.
     *
     * @return authorization endpoint uri as a string
     * @see Builder#authorizationEndpointUri(URI)
     */
    @Override
    public String authorizationEndpointUri() {
        return authorizationEndpointUri;
    }

    /**
     * Logout endpoint on OIDC server.
     *
     * @return URI of the logout endpoint
     * @see Builder#logoutEndpointUri(java.net.URI)
     */
    @Override
    public URI logoutEndpointUri() {
        return logoutEndpointUri;
    }

    /**
     * Client id of this client.
     *
     * @return client id
     * @see Builder#clientId(String)
     */
    @Override
    public String clientId() {
        return clientId;
    }

    /**
     * Redirect URI with host information.
     *
     * @return redirect URI
     * @see Builder#redirectUri(String)
     */
    @Override
    public String redirectUriWithHost() {
        if (frontendUri == null) {
            throw new SecurityException("Frontend URI is not defined");
        }
        return frontendUri + redirectUri;
    }

    /**
     * Redirect URI with host information taken from request,
     *  unless an explicit frontend uri is defined in configuration.
     *
     * @param frontendUri the frontend uri
     * @return redirect URI
     */
    @Override
    public String redirectUriWithHost(String frontendUri) {
        if (this.frontendUri != null) {
            return redirectUriWithHost();
        }
        return frontendUri + this.redirectUri;
    }

    /**
     * Base scopes to require from OIDC server.
     *
     * @return base scopes
     * @see Builder#baseScopes(String)
     */
    @Override
    public String baseScopes() {
        return baseScopes;
    }

    /**
     * Whether to validate JWT with JWK information (e.g. verify signatures locally).
     *
     * @return if we should validate JWT with JWK
     * @see Builder#validateJwtWithJwk(Boolean)
     */
    @Override
    public boolean validateJwtWithJwk() {
        return validateJwtWithJwk;
    }

    /**
     * Token introspection endpoint.
     *
     * @return introspection endpoint
     * @see Builder#introspectEndpointUri(URI)
     *@deprecated Please use {@link #appWebClient()} and {@link #introspectUri()} instead; result of moving to
     *      reactive webclient from JAX-RS client
     */
    @Override
    public WebTarget introspectEndpoint() {
        return introspectEndpoint;
    }

    /**
     * Introspection endpoint URI.
     *
     * @return introspection endpoint URI
     * @see Builder#introspectEndpointUri(java.net.URI)
     */
    @Override
    public URI introspectUri() {
        if (introspectUri == null) {
            throw new SecurityException("Introspect URI is not configured when using validate with JWK.");
        }
        return introspectUri;
    }

    /**
     * Token issuer.
     *
     * @return token issuer
     * @see Builder#issuer(String)
     */
    @Override
    public String issuer() {
        return issuer;
    }

    /**
     * Expected token audience.
     *
     * @return audience
     * @see Builder#audience(String)
     */
    @Override
    public String audience() {
        return audience;
    }

    /**
     * Identity server URI.
     *
     * @return identity server URI
     * @see Builder#identityUri(URI)
     */
    @Override
    public URI identityUri() {
        return identityUri;
    }

    /**
     * Client with configured proxy with no security.
     *
     * @return client for general use.
     * @deprecated Use {@link #generalWebClient()} instead
     */
    @Override
    public Client generalClient() {
        return generalClient;
    }

    /**
     * Client with configured proxy with no security.
     *
     * @return client for general use.
     */
    @Override
    public WebClient generalWebClient() {
        return webClient;
    }

    /**
     * Client with configured proxy and security of this OIDC client.
     *
     * @return client for communication with OIDC server
     * @deprecated Use {@link #appWebClient()}
     */
    @Override
    public Client appClient() {
        return appClient;
    }

    @Override
    public WebClient appWebClient() {
        return appWebClient;
    }

    /**
     * Whether to redirect to identity server if user is not authenticated.
     *
     * @return whether to redirect, defaults to true
     */
    @Override
    public boolean shouldRedirect() {
        return redirect;
    }

    /**
     * Realm to use for WWW-Authenticate response (if needed).
     *
     * @return realm name
     */
    @Override
    public String realm() {
        return realm;
    }

    /**
     * Name of the parameter used in state passed to OIDC to store the number of attempted redirects.
     * This is to prevent infinite redirects.
     *
     * @return name of the query parameter
     */
    @Override
    public String redirectAttemptParam() {
        return redirectAttemptParam;
    }

    /**
     * Maximal number of redirects allowed between Helidon and OIDC provider.
     *
     * @return maximal number of redirects
     */
    @Override
    public int maxRedirects() {
        return maxRedirects;
    }

    /**
     * Type of authentication mechanism used for token endpoint.
     *
     * @return client authentication type
     */
    @Override
    public ClientAuthentication tokenEndpointAuthentication() {
        return tokenEndpointAuthentication;
    }

    /**
     * Update request that uses form params with authentication.
     *
     * @param type type of the request
     * @param request request builder
     * @param form form params builder
     */
    @Override
    public void updateRequest(RequestType type, WebClientRequestBuilder request, FormParams.Builder form) {
        if (type == RequestType.CODE_TO_TOKEN && tokenEndpointAuthentication == ClientAuthentication.CLIENT_SECRET_POST) {
            form.add("client_id", clientId);
            form.add("client_secret", clientSecret);
        }
    }

    /**
     * Expected timeout of HTTP client operations.
     *
     * @return client timeout
     */
    @Override
    public Duration clientTimeout() {
        return clientTimeout;
    }

    /**
     * Cross-origin resource sharing settings.
     *
     * @return CORS settings
     */
    @Override
    public CrossOriginConfig crossOriginConfig() {
        return crossOriginConfig;
    }

    /**
     * Amount of time access token should be refreshed before its expiration time.
     *
     * @return refresh time skew
     */
    @Override
    public Duration tokenRefreshSkew() {
        return tokenRefreshSkew;
    }

}

/*
 * Copyright (c) 2018, 2022 Oracle and/or its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.helidon.security.providers.oidc.common;

import java.net.URI;
import java.time.Duration;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.logging.Logger;

import javax.json.JsonObject;
import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.WebTarget;

import io.helidon.common.Errors;
import io.helidon.common.LazyValue;
import io.helidon.common.configurable.Resource;
import io.helidon.common.http.Http;
import io.helidon.common.http.SetCookie;
import io.helidon.common.reactive.Single;
import io.helidon.config.Config;
import io.helidon.config.metadata.Configured;
import io.helidon.config.metadata.ConfiguredOption;
import io.helidon.security.SecurityException;
import io.helidon.security.jwt.jwk.JwkKeys;
import io.helidon.security.providers.oidc.common.spi.TenantConfigFinder;
import io.helidon.security.util.TokenHandler;
import io.helidon.webclient.WebClient;
import io.helidon.webclient.WebClientRequestBuilder;
import io.helidon.webserver.cors.CrossOriginConfig;

/**
 * Configuration of OIDC usable from all resources that utilize OIDC specification, such as security provider, web server
 * extension and IDCS connectivity.
 * <p>
 * Some of the configuration options below use "resource" type. The following configuration
 * can be used for a resource (example for oidc-metadata key):
 * {@code
 * oidc-metadata-path: "path/on/filesystem"
 * oidc-metadata-resource-path: "class-path/resource"
 * oidc-metadata-url: "URI on the net"
 * oidc-metadata-content-plain: "Value of the resource in plain text"
 * oidc-metadata-content: "Value in base64 encoded bytes"
 * }
 * <p>
 * Configuration options required (under security.providers[].${name}):
 * <table class="config">
 * <caption>Mandatory configuration parameters</caption>
 * <tr>
 *     <th>key</th>
 *     <th>description</th>
 * </tr>
 * <tr>
 *     <td>client-id</td>
 *     <td>Client ID as generated by OIDC server</td>
 * </tr>
 * <tr>
 *     <td>client-secret</td>
 *     <td>Client secret as generated by OIDC server</td>
 * </tr>
 * <tr>
 *     <td>identity-uri</td>
 *     <td>URI of the identity server, base used to retrieve OIDC metadata</td>
 * </tr>
 * <tr>
 *     <td>frontend-uri</td>
 *     <td>Fully URI of the frontend for redirects back from OIDC server (e.g. http://myserver/myApp)</td>
 * </tr>
 * </table>
 *
 * <table class="config">
 * <caption>Optional configuration parameters</caption>
 * <tr>
 *     <th>key</th>
 *     <th>default value</th>
 *     <th>description</th>
 * </tr>
 * <tr>
 *     <td>proxy-protocol</td>
 *     <td>http</td>
 *     <td>Proxy protocol to use when proxy is used.</td>
 * </tr>
 * <tr>
 *     <td>proxy-host</td>
 *     <td>null</td>
 *     <td>Proxy host to use. When defined, triggers usage of proxy for HTTP requests.</td>
 * </tr>
 * <tr>
 *     <td>proxy-port</td>
 *     <td>80</td>
 *     <td>Port of the proxy server to use</td>
 * </tr>
 * <tr>
 *     <td>relative-uris</td>
 *     <td>false</td>
 *     <td>Flag to force the use of relative URIs in all requests. By default,
 *          requests that use the Proxy will have absolute URIs. Set this flag to
 *          true if the host is unable to accept absolute URIs.</td>
 * </tr>
 * <tr>
 *     <td>redirect-uri</td>
 *     <td>/oidc/redirect</td>
 *     <td>URI to register web server component on, used by the OIDC server to
 *          redirect authorization requests to after a user logs in or approves scopes. Note that usually the redirect URI
 *          configured here must be the same one as configured on OIDC server.</td>
 * </tr>
 * <tr>
 *     <td>scope-audience</td>
 *     <td>empty string</td>
 *     <td>Audience of the scope required by this application. This is prefixed to
 *          the scope name when requesting scopes from the identity server.</td>
 * </tr>
 * <tr>
 *     <td>cookie-use</td>
 *     <td>true</td>
 *     <td>Whether to use cookie to store JWT. If used, redirects happen only in case the user
 *              is not authenticated or has insufficient scopes</td>
 * </tr>
 * <tr>
 *     <td>cookie-name</td>
 *     <td>JSESSIONID</td>
 *     <td>Name of the cookie</td>
 * </tr>
 * <tr>
 *     <td>cookie-domain</td>
 *     <td>null</td>
 *     <td>Domain the cookie is valid for. Not used by default</td>
 * </tr>
 * <tr>
 *     <td>cookie-path</td>
 *     <td>/</td>
 *     <td>Path the cookie is valid for.</td>
 * </tr>
 * <tr>
 *     <td>cookie-max-age-seconds</td>
 *     <td>null</td>
 *     <td>When using cookie, used to set MaxAge attribute of the cookie, defining
 *              how long the cookie is valid.</td>
 * </tr>
 * <tr>
 *     <td>cookie-http-only</td>
 *     <td>true</td>
 *     <td>When using cookie, if set to true, the HttpOnly attribute will be configured.</td>
 * </tr>
 * <tr>
 *     <td>cookie-secure</td>
 *     <td>false</td>
 *     <td>When using cookie, if set to true, the Secure attribute will be configured.</td>
 * </tr>
 * <tr>
 *     <td>cookie-same-site</td>
 *     <td>Lax</td>
 *     <td>When using cookie, used to set the SameSite cookie value. Can be "Strict" or "Lax".
 *     Setting this to "Strict" will result in infinite redirects when calling OIDC on a different host.
 *     </td>
 * </tr>
 * <tr>
 *     <td>query-param-use</td>
 *     <td>false</td>
 *     <td>Whether to expect JWT in a query parameter</td>
 * </tr>
 * <tr>
 *     <td>query-param-name</td>
 *     <td>accessToken</td>
 *     <td>Name of a query parameter that contains the JWT token when parameter is used.</td>
 * </tr>
 * <tr>
 *     <td>header-use</td>
 *     <td>false</td>
 *     <td>Whether to expect JWT in a header field.</td>
 * </tr>
 * <tr>
 *     <td>header-token</td>
 *     <td>"Authorization" header with prefix "bearer "</td>
 *     <td>A {@link TokenHandler} configuration to process header containing a JWT</td>
 * </tr>
 * <tr>
 *     <td>oidc-metadata-well-known</td>
 *     <td>true</td>
 *     <td>If set to true, metadata will be loaded from default (well known)
 *          location, unless it is explicitly defined using oidc-metadata-resource. If set to false, it would not be loaded even
 *          if oidc-metadata-resource is not defined. In such a case all URIs must be explicitly
 *          defined (e.g. token-endpoint-uri).</td>
 * </tr>
 * <tr>
 *     <td>oidc-metadata.resource</td>
 *     <td>identity-uri/.well-known/openid-configuration</td>
 *     <td>Resource configuration for OIDC Metadata containing endpoints to various identity services, as well as information
 *     about the identity server. See {@link Resource#create(io.helidon.config.Config)}</td>
 * </tr>
 * <tr>
 *     <td>token-endpoint-uri</td>
 *     <td>token_endpoint in OIDC metadata, or identity-url/oauth2/v1/token if not available</td>
 *     <td>URI of a token endpoint used to obtain a JWT based on the authentication code.</td>
 * </tr>
 * <tr>
 *     <td>authorization-endpoint-uri</td>
 *     <td>"authorization_endpoint" in OIDC metadata, or identity-uri/oauth2/v1/authorize if not available</td>
 *     <td>URI of an authorization endpoint used to redirect users to for logging-in.</td>
 * </tr>
 * <tr>
 *     <td>validate-with-jwk</td>
 *     <td>true</td>
 *     <td>When true  - validate against jwk defined by "sign-jwk", when false
 *          validate JWT through OIDC Server endpoint "validation-endpoint-uri"</td>
 * </tr>
 * <tr>
 *     <td>sign-jwk.resource</td>
 *     <td>"jwks-uri" in OIDC metadata, or identity-uri/admin/v1/SigningCert/jwk if not available, only needed
 *              when jwt validation is done by us</td>
 *     <td>A resource pointing to JWK with public keys of signing certificates used to validate JWT.
 *     See {@link Resource#create(io.helidon.config.Config)}</td>
 * </tr>
 * <tr>
 *     <td>introspect-endpoint-uri</td>
 *     <td>"introspection_endpoint" in OIDC metadata, or identity-uri/oauth2/v1/introspect</td>
 *     <td>When validate-with-jwk is set to "false", this is the endpoint used</td>
 * </tr>
 * <tr>
 *     <td>base-scopes</td>
 *     <td>{@value DEFAULT_BASE_SCOPES}</td>
 *     <td>Configure scopes to be requested by default. If the scope has a qualifier, it must be included here</td>
 * </tr>
 * <tr>
 *     <td>redirect</td>
 *     <td>true</td>
 *     <td>Whether to redirect to identity server when authentication failed.</td>
 * </tr>
 * <tr>
 *     <td>realm</td>
 *     <td>helidon</td>
 *     <td>Realm returned in HTTP response if redirect is not enabled or possible.</td>
 * </tr>
 * <tr>
 *     <td>redirect-attempt-param</td>
 *     <td>{@value DEFAULT_ATTEMPT_PARAM}</td>
 *     <td>Query parameter holding the number of times we redirected to an identity server. Customizable to prevent
 *     conflicts with application parameters</td>
 * </tr>
 * <tr>
 *     <td>max-redirects</td>
 *     <td>{@value DEFAULT_MAX_REDIRECTS}</td>
 *     <td>Maximal number of times we can redirect to an identity server. When the number is reached, no further redirects
 *     happen and the request finishes with an error (status {@code 401})</td>
 * </tr>
 * <tr>
 *     <td>server-type</td>
 *     <td>&nbsp;</td>
 *     <td>Type of identity server. Currently supported is {@code idcs} or not configured (for default).</td>
 * </tr>
 * <tr>
 *     <td>{@code client-timeout-millis}</td>
 *     <td>30 seconds</td>
 *     <td>Timeout on HTTP client calls</td>
 * </tr>
 * <tr>
 *     <td>{@code cookie-encryption-enabled}</td>
 *     <td>Depends on other configuration</td>
 *     <td>Whether cookies should be encrypted. Will be enabled if logout is enabled.</td>
 * </tr>
 * <tr>
 *     <td>{@code cookie-encryption-password}</td>
 *     <td>Generated for this service (as a file)</td>
 *     <td>Encryption password to be used for symmetric cipher. Must be the same for all services that are intended
 *     to share a cookie as a form of authentication</td>
 * </tr>
 * <tr>
 *     <td>{@code cookie-encryption-name}</td>
 *     <td>&nbsp;</td>
 *     <td>Name of encryption configuration in {@link io.helidon.security.Security}. If used, security must be registered
 *     in curent context or in global context (this is done automatically in Helidon MP).</td>
 * </tr>
 * <tr>
 *     <td>{@code logout-endpoint-uri}</td>
 *     <td>From well known metadata endpoint</td>
 *     <td>Endpoint to redirect user to log out from OIDC server.</td>
 * </tr>
 * <tr>
 *     <td>{@code post-logout-uri}</td>
 *     <td>&nbsp;</td>
 *     <td>Required if logout is enabled. Endpoint the OIDC server redirects back to after logging user out.</td>
 * </tr>
 * <tr>
 *     <td>{@code logout-enabled}</td>
 *     <td>{@code false}</td>
 *     <td>Whether logout support should be enabled. Requires encryption of cookies (and cookies must be used).</td>
 * </tr>
 * <tr>
 *     <td>{@code cors}</td>
 *     <td>&nbsp;</td>
 *     <td>Cross-origin resource sharing settings. See {@link io.helidon.webserver.cors.CrossOriginConfig}.</td>
 * </tr>
 * <tr>
 *     <td>{@code force-https-redirects}</td>
 *     <td>&nbsp;</td>
 *     <td>Force https for redirects to identity provider.
 *     This is helpful if you have a frontend SSL or cloud load balancer in front and Helidon is serving plain http.</td>
 * </tr>
 * </table>
 */
public final class OidcConfig extends TenantConfig {
    /**
     * Default name of the header we expect JWT in.
     */
    public static final String PARAM_HEADER_NAME = "X_OIDC_TOKEN_HEADER";
    static final String DEFAULT_REDIRECT_URI = "/oidc/redirect";
    static final String DEFAULT_LOGOUT_URI = "/oidc/logout";
    static final boolean DEFAULT_REDIRECT = true;
    static final String DEFAULT_ATTEMPT_PARAM = "h_ra";
    static final int DEFAULT_MAX_REDIRECTS = 5;
    static final boolean DEFAULT_FORCE_HTTPS_REDIRECTS = false;
    static final Duration DEFAULT_TOKEN_REFRESH_SKEW = Duration.ofSeconds(5);
    static final boolean DEFAULT_RELATIVE_URIS = false;
    static final int DEFAULT_PROXY_PORT = 80;
    static final String DEFAULT_PROXY_PROTOCOL = "http";
    static final String TENANT_IDENT = "name";

    private static final Logger LOGGER = Logger.getLogger(OidcConfig.class.getName());

    private final Map<String, TenantConfig> tenantConfigurations;
    private final String redirectUri;
    private final String logoutUri;
    private final boolean logoutEnabled;
    private final String frontendUri;
    private final boolean redirect;
    private final String redirectAttemptParam;
    private final int maxRedirects;
    private final URI postLogoutUri;
    private final CrossOriginConfig crossOriginConfig;
    private final boolean forceHttpsRedirects;
    private final Duration tokenRefreshSkew;
    private final boolean relativeUris;
    private final Client generalClient;
    private final WebClient webClient;
    private final LazyValue<Optional<WebTarget>> introspectEndpoint;
    private final Supplier<WebClient.Builder> webClientBuilderSupplier;
    private final Supplier<ClientBuilder> jaxrsClientBuilderSupplier;
    private final LazyValue<Tenant> defaultTenant;

    private OidcConfig(Builder builder) {
        super(builder);
        this.frontendUri = builder.frontendUri;
        this.redirectUri = builder.redirectUri;
        this.logoutUri = builder.logoutUri;
        this.logoutEnabled = builder.logoutEnabled;
        this.postLogoutUri = builder.postLogoutUri;
        this.redirect = builder.redirect;
        this.redirectAttemptParam = builder.redirectAttemptParam;
        this.maxRedirects = builder.maxRedirects;
        this.forceHttpsRedirects = builder.forceHttpsRedirects;
        this.crossOriginConfig = builder.crossOriginConfig;
        this.tokenRefreshSkew = builder.tokenRefreshSkew;
        this.tenantConfigurations = Map.copyOf(builder.tenantConfigurations);
        this.webClient = builder.webClient;
        this.generalClient = builder.generalClient;
        this.relativeUris = builder.relativeUris;

        if (builder.validateJwtWithJwk()) {
            this.introspectEndpoint = LazyValue.create(Optional.empty());
        } else {
            this.introspectEndpoint = LazyValue.create(() -> Optional.of(appClient().target(builder.introspectUri())));
        }

        this.webClientBuilderSupplier = builder.webClientBuilderSupplier;
        this.jaxrsClientBuilderSupplier = builder.jaxrsClientBuilderSupplier;
        this.defaultTenant = LazyValue.create(() -> Tenant.create(this, this));

        LOGGER.finest(() -> "Redirect URI with host: " + frontendUri + redirectUri);
    }

    /**
     * Create a builder to programmatically construct OIDC configuration.
     *
     * @return a new builder instance usable for fluent API
     */
    public static Builder builder() {
        return new Builder();
    }

    /**
     * Create a new instance from {@link Config}.
     * The config instance has to be on the node containing keys used by this class (e.g. client-id).
     *
     * @param config configuration used to obtain OIDC integration values
     * @return a new instance of this class configured from provided config
     */
    public static OidcConfig create(Config config) {
        return OidcConfig.builder()
                .config(config)
                .build();
    }

    /**
     * Processing of {@link io.helidon.webclient.WebClient} submit using a POST method.
     * This is a helper method to handle possible cases (success, failure with readable entity, failure).
     *
     * @param requestBuilder WebClient request builder
     * @param toSubmit object to submit (such as {@link io.helidon.common.http.FormParams}
     * @param jsonProcessor processor of successful JSON response
     * @param errorEntityProcessor processor of an error that has an entity, to fail the single
     * @param errorProcessor processor of an error that does not have an entity
     * @param <T> type of the result the call
     * @return a future that completes successfully if processed from json, or if an error processor returns a non-empty value,
     *      completes with error otherwise
     */
    public static <T> Single<T> postJsonResponse(WebClientRequestBuilder requestBuilder,
                                                 Object toSubmit,
                                                 Function<JsonObject, T> jsonProcessor,
                                                 BiFunction<Http.ResponseStatus, String, Optional<T>> errorEntityProcessor,
                                                 BiFunction<Throwable, String, Optional<T>> errorProcessor) {
        return requestBuilder.submit(toSubmit)
                .flatMapSingle(response -> {
                    if (response.status().family() == Http.ResponseStatus.Family.SUCCESSFUL) {
                        return response.content()
                                .as(JsonObject.class)
                                .map(jsonProcessor)
                                .onErrorResumeWithSingle(t -> errorProcessor.apply(t, "Failed to read JSON from response")
                                        .map(Single::just)
                                        .orElseGet(() -> Single.error(t)));
                    } else {
                        return response.content()
                                .as(String.class)
                                .flatMapSingle(it -> errorEntityProcessor.apply(response.status(), it)
                                        .map(Single::just)
                                        .orElseGet(() -> Single.error(new SecurityException("Failed to process request: " + it))))
                                .onErrorResumeWithSingle(t -> errorProcessor.apply(t, "Failed to process error entity")
                                        .map(Single::just)
                                        .orElseGet(() -> Single.error(t)));
                    }
                })
                .onErrorResumeWithSingle(t -> errorProcessor.apply(t, "Failed to invoke request")
                        .map(Single::just)
                        .orElseGet(() -> Single.error(t)));

    }

    /**
     * Redirection URI.
     *
     * @return uri the OIDC server redirects back to
     * @see Builder#redirectUri(String)
     */
    public String redirectUri() {
        return redirectUri;
    }

    /**
     * Whether to force https when redirecting to identity provider.
     *
     * @return {@code true} to force use of https
     */
    public boolean forceHttpsRedirects() {
        return forceHttpsRedirects;
    }

    /**
     * Whether logout is enabled.
     *
     * @return {@code true} if logout is enabled
     */
    public boolean logoutEnabled() {
        return logoutEnabled;
    }

    /**
     * Logout URI.
     *
     * @return uri that processes logout in Helidon and redirects to OIDC server logout
     * @see Builder#logoutUri(String)
     */
    public String logoutUri() {
        return logoutUri;
    }

    /**
     * Post logout redirect URI.
     *
     * @return uri that OIDC server redirects to once logout is finished
     * @see Builder#postLogoutUri(java.net.URI)
     */
    public URI postLogoutUri() {
        return postLogoutUri;
    }

    /**
     * Redirect URI with host information.
     *
     * @return redirect URI
     * @see Builder#redirectUri(String)
     */
    public String redirectUriWithHost() {
        if (frontendUri == null) {
            throw new SecurityException("Frontend URI is not defined");
        }
        return frontendUri + redirectUri;
    }

    /**
     * Redirect URI with host information taken from request,
     *  unless an explicit frontend uri is defined in configuration.
     *
     * @param frontendUri the frontend uri
     * @return redirect URI
     */
    public String redirectUriWithHost(String frontendUri) {
        if (this.frontendUri != null) {
            return redirectUriWithHost();
        }
        return frontendUri + this.redirectUri;
    }

    /**
     * Whether to redirect to identity server if user is not authenticated.
     *
     * @return whether to redirect, defaults to true
     */
    public boolean shouldRedirect() {
        return redirect;
    }

    /**
     * Name of the parameter used in state passed to OIDC to store the number of attempted redirects.
     * This is to prevent infinite redirects.
     *
     * @return name of the query parameter
     */
    public String redirectAttemptParam() {
        return redirectAttemptParam;
    }

    /**
     * Maximal number of redirects allowed between Helidon and OIDC provider.
     *
     * @return maximal number of redirects
     */
    public int maxRedirects() {
        return maxRedirects;
    }

    /**
     * Cross-origin resource sharing settings.
     *
     * @return CORS settings
     */
    public CrossOriginConfig crossOriginConfig() {
        return crossOriginConfig;
    }

    /**
     * Amount of time access token should be refreshed before its expiration time.
     *
     * @return refresh time skew
     */
    public Duration tokenRefreshSkew() {
        return tokenRefreshSkew;
    }

    /**
     * Determines whether to force the use of relative URIs in all requests,
     * regardless of the presence or absence of proxies or no-proxy lists.
     *
     * @return {@code true} if we should use relative URIs
     */
    public boolean relativeUris() {
        return relativeUris;
    }

    /**
     * Client with configured proxy with no security.
     *
     * @return client for general use.
     * @deprecated Use {@link #generalWebClient()} instead
     */
    @Deprecated(forRemoval = true, since = "2.4.0")
    public Client generalClient() {
        return generalClient;
    }

    /**
     * Client with configured proxy with no security.
     *
     * @return client for general use.
     */
    public WebClient generalWebClient() {
        return webClient;
    }

    /**
     * Client with configured proxy and security of this OIDC client.
     *
     * @return client for communication with OIDC server
     * @deprecated Use {@link #appWebClient()}
     */
    @Deprecated(forRemoval = true, since = "2.4.0")
    public Client appClient() {
        return defaultTenant.get().appClient();
    }

    /**
     * Client with configured proxy and security.
     *
     * @return client for communicating with OIDC identity server
     */
    public WebClient appWebClient() {
        return defaultTenant.get().appWebClient();
    }

    /**
     * Token endpoint of the OIDC server.
     *
     * @return target the endpoint is on
     * @see TenantConfig.Builder#tokenEndpointUri(URI)
     * @deprecated Please use {@link #appWebClient()} and {@link #tokenEndpointUri()} instead; result of moving to
     *      reactive webclient from JAX-RS client
     */
    @Deprecated(forRemoval = true, since = "2.4.0")
    public WebTarget tokenEndpoint() {
        return defaultTenant.get().tokenEndpoint();
    }

    /**
     * Token introspection endpoint.
     *
     * @return introspection endpoint
     * @see OidcConfig.Builder#introspectEndpointUri(URI)
     *@deprecated Please use {@link #appWebClient()} and {@link #introspectUri()} instead; result of moving to
     *      reactive webclient from JAX-RS client
     */
    @Deprecated(forRemoval = true, since = "2.4.0")
    public WebTarget introspectEndpoint() {
        return introspectEndpoint.get().orElse(null);
    }

    /**
     * Return {@link TenantConfig} bound to the provided tenant id.
     * If no {@link TenantConfig} found, default OIDC configuration should be returned.
     *
     * @param tenantId tenant id of the configuration
     * @return configuration bound to the tenant id, or default oidc configuration if not found
     */
    public TenantConfig tenantConfig(String tenantId) {
        TenantConfig tenantConfig = tenantConfigurations.get(tenantId);
        if (tenantConfig == null) {
            return tenantConfigurations.getOrDefault(TenantConfigFinder.DEFAULT_TENANT_ID, this);
        }
        return tenantConfig;
    }

    @Override
    public URI tokenEndpointUri() {
        return beforeLazyLoaded(() -> defaultTenant.get().tokenEndpointUri(), super::tokenEndpointUri);
    }

    @Override
    public String authorizationEndpointUri() {
        return beforeLazyLoaded(() -> defaultTenant.get().authorizationEndpointUri(), super::authorizationEndpointUri);
    }

    @Override
    public URI logoutEndpointUri() {
        return beforeLazyLoaded(() -> defaultTenant.get().logoutEndpointUri(), super::logoutEndpointUri);
    }

    @Override
    public String issuer() {
        return beforeLazyLoaded(() -> defaultTenant.get().issuer(), super::issuer);
    }

    @Override
    public JwkKeys signJwk() {
        return beforeLazyLoaded(() -> defaultTenant.get().signJwk(), super::signJwk);
    }

    @Override
    public URI introspectUri() {
        return beforeLazyLoaded(() -> defaultTenant.get().introspectUri(), super::introspectUri);
    }

    Supplier<WebClient.Builder> webClientBuilderSupplier() {
        return webClientBuilderSupplier;
    }

    Supplier<ClientBuilder> jaxrsClientBuilderSupplier() {
        return jaxrsClientBuilderSupplier;
    }

    private <T> T beforeLazyLoaded(Supplier<T> loaded, Supplier<T> notLoaded) {
        return defaultTenant.isLoaded() ? loaded.get() : notLoaded.get();
    }


    /**
     * Client Authentication methods that are used by Clients to authenticate to the Authorization
     * Server when using the Token Endpoint.
     */
    public enum ClientAuthentication {
        /**
         * Clients that have received a client_secret value from the Authorization Server authenticate with the Authorization
         * Server in accordance with Section 2.3.1 of OAuth 2.0 [RFC6749] using the HTTP Basic authentication scheme.
         * This is the default client authentication.
         */
        CLIENT_SECRET_BASIC,
        /**
         * Clients that have received a client_secret value from the Authorization Server, authenticate with the Authorization
         * Server in accordance with Section 2.3.1 of OAuth 2.0 [RFC6749] by including the Client Credentials in the request body.
         */
        CLIENT_SECRET_POST,
        /**
         * Clients that have received a client_secret value from the Authorization Server create a JWT using an HMAC SHA
         * algorithm, such as HMAC SHA-256. The HMAC (Hash-based Message Authentication Code) is calculated using the octets of
         * the UTF-8 representation of the client_secret as the shared key.
         * The Client authenticates in accordance with JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and
         * Authorization Grants [OAuth.JWT] and Assertion Framework for OAuth 2.0 Client Authentication and Authorization
         * Grants [OAuth.Assertions].
         * <p>
         * The JWT MUST contain the following REQUIRED Claim Values and MAY contain the following
         * OPTIONAL Claim Values.
         * <p>
         * Required:
         * {@code iss, sub, aud, jti, exp}
         * <p>
         * Optional:
         * {@code iat}
         *
         *
         */
        CLIENT_SECRET_JWT,
        /**
         * Clients that have registered a public key sign a JWT using that key. The Client authenticates in accordance with
         * JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants [OAuth.JWT] and Assertion
         * Framework for OAuth 2.0 Client Authentication and Authorization Grants [OAuth.Assertions].
         * <p>
         * The JWT MUST contain the following REQUIRED Claim Values and MAY contain the following
         * OPTIONAL Claim Values.
         * <p>
         * Required:
         * {@code iss, sub, aud, jti, exp}
         * <p>
         * Optional:
         * {@code iat}
         */
        PRIVATE_KEY_JWT,
        /**
         * The Client does not authenticate itself at the Token Endpoint, either because it uses only the Implicit Flow (and so
         * does not use the Token Endpoint) or because it is a Public Client with no Client Secret or other authentication
         * mechanism.
         */
        NONE
    }

    /**
     * Types of requests to identity provider.
     */
    public enum RequestType {
        /**
         * Request to exchange code for a token issued against the token endpoint.
         */
        CODE_TO_TOKEN,
        /**
         * Request to validate a JWT against an introspection endpoint.
         */
        INTROSPECT_JWT;
    }

    /**
     * A fluent API {@link io.helidon.common.Builder} to build instances of {@link OidcConfig}.
     */
    @Configured(description = "Open ID Connect configuration")
    public static class Builder extends BaseBuilder<Builder, OidcConfig> {

        private final Map<String, TenantConfig> tenantConfigurations = new HashMap<>();

        // mandatory properties
        private String redirectUri = DEFAULT_REDIRECT_URI;
        private String logoutUri = DEFAULT_LOGOUT_URI;
        private boolean logoutEnabled = false;
        // optional properties
        private String frontendUri;
        private boolean redirect = DEFAULT_REDIRECT;
        private String redirectAttemptParam = DEFAULT_ATTEMPT_PARAM;
        private int maxRedirects = DEFAULT_MAX_REDIRECTS;
        private URI postLogoutUri;
        private CrossOriginConfig crossOriginConfig;
        private boolean forceHttpsRedirects = DEFAULT_FORCE_HTTPS_REDIRECTS;
        private Duration tokenRefreshSkew = DEFAULT_TOKEN_REFRESH_SKEW;
        private String proxyHost;
        private String proxyProtocol = DEFAULT_PROXY_PROTOCOL;
        private int proxyPort = DEFAULT_PROXY_PORT;
        @Deprecated
        private Client generalClient;
        private WebClient webClient;
        private Supplier<WebClient.Builder> webClientBuilderSupplier;
        private Supplier<ClientBuilder> jaxrsClientBuilderSupplier;
        private boolean relativeUris = DEFAULT_RELATIVE_URIS;

        protected Builder() {
        }

        @Override
        public OidcConfig build() {
            buildConfiguration();

            Errors.Collector collector = Errors.collector();
            if (useCookie() && logoutEnabled) {
                if (postLogoutUri == null) {
                    collector.fatal("post-logout-uri must be defined when logout is enabled.");
                }
            }

            // second set of validations
            collector.collect().checkValid();

            if (cookieSameSiteDefault() && useCookie()) {
                // compare frontend and oidc endpoints to see if
                // we should use lax or strict by default
                if (identityUri() != null) {
                    String identityHost = identityUri().getHost();
                    if (frontendUri != null) {
                        String frontendHost = URI.create(frontendUri).getHost();
                        if (identityHost.equals(frontendHost)) {
                            LOGGER.info("As frontend host and identity host are equal, setting Same-Site policy to Strict"
                                                + " this can be overridden using configuration option of OIDC: "
                                                + "\"cookie-same-site\"");
                            this.tokenCookieBuilder().sameSite(SetCookie.SameSite.STRICT);
                            this.idTokenCookieBuilder().sameSite(SetCookie.SameSite.STRICT);
                        }
                    }
                }
            }

            if (logoutEnabled) {
                idTokenCookieBuilder().encryptionEnabled(true);
            }

            this.webClientBuilderSupplier = () -> OidcUtil.webClientBaseBuilder(proxyHost,
                                                                                proxyPort,
                                                                                clientTimeout());
            this.jaxrsClientBuilderSupplier = () -> OidcUtil.clientBaseBuilder(proxyProtocol, proxyHost, proxyPort);

            this.generalClient = jaxrsClientBuilderSupplier.get().build();
            this.webClient = webClientBuilderSupplier.get().build();

            return new OidcConfig(this);
        }

        /**
         * Update this builder with values from configuration.
         *
         * @param config configuration located on node with OIDC configuration keys (e.g. client-id)
         * @return updated builder instance
         */
        public Builder config(Config config) {
            super.config(config);
            // mandatory configuration
            config.get("frontend-uri").asString().ifPresent(this::frontendUri);

            // environment
            config.get("proxy-protocol")
                    .asString()
                    .ifPresent(this::proxyProtocol);
            config.get("proxy-host").asString().ifPresent(this::proxyHost);
            config.get("proxy-port").asInt().ifPresent(this::proxyPort);
            config.get("relative-uris").asBoolean().ifPresent(this::relativeUris);

            // our application
            config.get("redirect-uri").asString().ifPresent(this::redirectUri);

            config.get("post-logout-uri").as(URI.class).ifPresent(this::postLogoutUri);
            config.get("logout-enabled").asBoolean().ifPresent(this::logoutEnabled);

            config.get("redirect").asBoolean().ifPresent(this::redirect);
            config.get("redirect-attempt-param").asString().ifPresent(this::redirectAttemptParam);
            config.get("max-redirects").asInt().ifPresent(this::maxRedirects);
            config.get("force-https-redirects").asBoolean().ifPresent(this::forceHttpsRedirects);

            config.get("cors").as(CrossOriginConfig::create).ifPresent(this::crossOriginConfig);

            config.get("token-refresh-before-expiration").as(Duration.class).ifPresent(this::tokenRefreshSkew);

            config.get("tenants").asList(Config.class)
                    .ifPresent(confList -> confList.forEach(tenantConfig -> tenantFromConfig(config, tenantConfig)));

            return this;
        }



        private void tenantFromConfig(Config defaultConfig, Config tenantConfig) {
            String name = tenantConfig.get(TENANT_IDENT).asString()
                    .orElseThrow(() -> new IllegalStateException("Every tenant need to have \"" + TENANT_IDENT + "\" specified"));
            addTenantConfig(name, TenantConfig.tenantBuilder().config(defaultConfig).config(tenantConfig).build());

        }

        /**
         * Amount of time access token should be refreshed before its expiration time.
         * Default is 5 seconds.
         *
         * @param tokenRefreshSkew time to refresh token before expiration
         * @return updated builder
         */
        public Builder tokenRefreshSkew(Duration tokenRefreshSkew) {
            this.tokenRefreshSkew = tokenRefreshSkew;
            return this;
        }

        /**
         * Assign cross-origin resource sharing settings.
         *
         * @param crossOriginConfig cross-origin settings to apply to the redirect endpoint
         * @return updated builder instance
         */
        public Builder crossOriginConfig(CrossOriginConfig crossOriginConfig) {
            this.crossOriginConfig = crossOriginConfig;
            return this;
        }

        /**
         * Whether to enable logout support.
         * When logout is enabled, we use two cookies (User token and user ID token) and we expose
         * an endpoint {@link #logoutUri(String)} that can be used to log the user out from Helidon session
         * and also from OIDC session (uses {@link #logoutEndpointUri(java.net.URI)} on OIDC server).
         * Logout support is disabled by default.
         *
         * @param logoutEnabled whether to enable logout
         * @return updated builder instance
         */
        public Builder logoutEnabled(Boolean logoutEnabled) {
            this.logoutEnabled = logoutEnabled;
            return this;
        }

        /**
         * By default, the client should redirect to the identity server for the user to log in.
         * This behavior can be overridden by setting redirect to false. When token is not present in the request, the client
         * will not redirect and just return appropriate error response code.
         *
         * @param redirect Whether to redirect to OIDC server in case the request does not contain sufficient information to
         *                 authenticate the user, defaults to true
         * @return updated builder instance
         */
        @ConfiguredOption("true")
        public Builder redirect(boolean redirect) {
            this.redirect = redirect;
            return this;
        }

        /**
         * Full URI of this application that is visible from user browser.
         * Used to redirect request back from identity server after successful login.
         *
         * @param uri the frontend URI, such as "http://my.server.com/myApp
         * @return updated builder instance
         */
        @ConfiguredOption
        public Builder frontendUri(String uri) {
            this.frontendUri = uri;
            return this;
        }

        /**
         * Force HTTPS for redirects to identity provider.
         * Defaults to {@code false}.
         *
         * @param forceHttpsRedirects flag to redirect with https
         * @return updated builder instance
         */
        @ConfiguredOption("false")
        public Builder forceHttpsRedirects(boolean forceHttpsRedirects) {
            this.forceHttpsRedirects = forceHttpsRedirects;
            return this;
        }

        /**
         * Can be set to {@code true} to force the use of relative URIs in all requests,
         * regardless of the presence or absence of proxies or no-proxy lists. By default,
         * requests that use the Proxy will have absolute URIs. Set this flag to {@code true}
         * if the host is unable to accept absolute URIs.
         * Defaults to {@value #DEFAULT_RELATIVE_URIS}.
         *
         * @param  relativeUris relative URIs flag
         * @return updated builder instance
         */
        @ConfiguredOption("false")
        public Builder relativeUris(boolean relativeUris) {
            this.relativeUris = relativeUris;
            return this;
        }

        /**
         * URI to register web server component on, used by the OIDC server to
         * redirect authorization requests to after a user logs in or approves
         * scopes.
         * Note that usually the redirect URI configured here must be the
         * same one as configured on OIDC server.
         *
         * <p>
         * Defaults to {@value #DEFAULT_REDIRECT_URI}
         *
         * @param redirectUri the URI (path without protocol, host and port) used to redirect requests back to us
         * @return updated builder instance
         */
        @ConfiguredOption(value = DEFAULT_REDIRECT_URI)
        public Builder redirectUri(String redirectUri) {
            this.redirectUri = redirectUri;
            return this;
        }

        /**
         * Path to register web server for logout link.
         * This should be used by application to redirect user to logout the current user
         * from Helidon based session (when using cookies and redirection).
         * This endpoint will logout user from Helidon session (remove Helidon cookies) and redirect user to
         * logout screen of the OIDC server.
         *
         * @param logoutUri URI path for logout component
         * @return updated builder instance
         */
        public Builder logoutUri(String logoutUri) {
            this.logoutUri = logoutUri;
            return this;
        }

        /**
         * URI to redirect to once the logout process is done.
         * The endpoint should not be protected by OIDC (as this would serve no purpose, just to log the user in again).
         * This endpoint usually must be registered with the application as the allowed post-logout redirect URI.
         * Note that the URI should not contain any query parameters. You can obtain state using the
         * state query parameter that must be provided to {@link #logoutUri(String)}.
         *
         * @param uri this will be used by the OIDC server to redirect user to once logout is done, can define just path,
         *            in which case the scheme, host and port will be taken from request.
         * @return updated builder instance
         */
        public Builder postLogoutUri(URI uri) {
            this.postLogoutUri = uri;
            return this;
        }

        /**
         * Configure the parameter used to store the number of attempts in redirect.
         * <p>
         * Defaults to {@value #DEFAULT_ATTEMPT_PARAM}
         * @param paramName name of the parameter used in the state parameter
         * @return updated builder instance
         */
        @ConfiguredOption(value = DEFAULT_ATTEMPT_PARAM)
        public Builder redirectAttemptParam(String paramName) {
            this.redirectAttemptParam = paramName;
            return this;
        }

        /**
         * Configure maximal number of redirects when redirecting to an OIDC provider within a single authentication
         * attempt.
         * <p>
         * Defaults to {@value #DEFAULT_MAX_REDIRECTS}
         * @param maxRedirects maximal number of redirects from Helidon to OIDC provider
         * @return updated builder instance
         */
        @ConfiguredOption("5")
        public Builder maxRedirects(int maxRedirects) {
            this.maxRedirects = maxRedirects;
            return this;
        }

        /**
         * Proxy protocol to use when proxy is used.
         * Defaults to {@value DEFAULT_PROXY_PROTOCOL}.
         *
         * @param protocol protocol to use (such as https)
         * @return updated builder instance
         */
        @ConfiguredOption(value = DEFAULT_PROXY_PROTOCOL)
        public Builder proxyProtocol(String protocol) {
            this.proxyProtocol = protocol;
            return this;
        }

        /**
         * Proxy host to use. When defined, triggers usage of proxy for HTTP requests.
         * Setting to empty String has the same meaning as setting to null - disables proxy.
         *
         * @param proxyHost host of the proxy
         * @return updated builder instance
         * @see #proxyProtocol(String)
         * @see #proxyPort(int)
         */
        @ConfiguredOption
        public Builder proxyHost(String proxyHost) {
            if ((proxyHost == null) || proxyHost.isEmpty()) {
                this.proxyHost = null;
            } else {
                this.proxyHost = proxyHost;
            }
            return this;
        }

        /**
         * Proxy port.
         * Defaults to {@value DEFAULT_PROXY_PORT}
         *
         * @param proxyPort port of the proxy server to use
         * @return updated builder instance
         */
        @ConfiguredOption("80")
        public Builder proxyPort(int proxyPort) {
            this.proxyPort = proxyPort;
            return this;
        }

        /**
         * Add specific {@link TenantConfig} instance.
         *
         * @param tenant tenant name
         * @param tenantConfig tenant configuration
         * @return updated builder instance
         */
        public Builder addTenantConfig(String tenant, TenantConfig tenantConfig) {
            tenantConfigurations.put(tenant, tenantConfig);
            return this;
        }

    }
}
